# Introduction to the HCL library
Or the HashiCorp configuration language (language)
Tags: go, hcl, hcl2

Adrien Delorme
January 2022
adrien@hashicorp.com
https://github.com/azr/hcll_intro

## Some disclaimers
* HCL is currently at version 2 and stable.
* I (along with my team) only defined and implemented the Packer Configuration
  Language.

## I learned HCL along the way.

By looking at other Projects like Terraform or Nomad. 

I don't recommend doing that.

And I really hope this presentation can help you get started.

## HCL is not a data structure serialization language

Like JSON or YAML

## HCL allows to define configuration languages for tools

So it is better to say :
* The Terraform Configuration language
* The Nomad Configuration language
* The Packer Configuration language
* etc.

Applications intending to use HCL should think of it as a language design task
in its own.

I'm going to show how to do this.

## First some basics

## Some vocabulary

HCL files are made of :

 * bodies :

.code body.example.hcl

 * blocks :

.code block.example.hcl

 * arguments :

.code arguments.example.hcl

## Example file

.code complex.example.hcl

## 

.background parse.png

## HCL's super powers :

* Partial reads (get block a)
* Variables
* Functions


## Defining the Cooking configuration Language

It displays recipes nicely.

I want to be able describe how to:

* `slice` ingredients
* `boil` ingredients.
* stash ingredients together.

And then maybe print the recipe.

## Slicing:

.code tartiflette.recipy.hcl /\A/,/kind/

This is going to create a sliced_cheese variable.

## Slicing:

.code tartiflette.recipy.hcl /\A/,/kind/
.code recipy.go /preparationActionsSchema/,/"slice"/

BodySchema tells what blocks can be present in a body

## Slicing:

.code tartiflette.recipy.hcl /\A/,/kind/
.code recipy.go /preparationActionsSchema/,/"slice"/
.code recipy.go /preparationContent,/

* PartialContent return us 'just what we want' from our schema.
* The rest of the AST is in 'prepRest'.

## Slicing:

.code tartiflette.recipy.hcl /\A/,/kind/
.code recipy.go /preparationActionsSchema/,/"slice"/
.code recipy.go /preparationContent,/
.code recipy.go /range preparationContent.Blocks/,/this is empty/

## Nice, we can parse "slice". Now to boil.

## Boiling:

.code tartiflette.recipy.hcl /boil "potatoes/,/peel/

This is going to create a boiled_potatoes variable.

## Boiling:

.code tartiflette.recipy.hcl /boil "potatoes/,/peel/

.code recipy.go /preparationActionsSchema/,/"boil"/

## Boiling:

.code tartiflette.recipy.hcl /boil "potatoes/,/peel/

.code recipy.go /preparationActionsSchema/,/"boil"/

.code recipy.go /type Action struct/,/"duration"/

## Boiling:

.code recipy.go /range/
.code recipy.go /switch/,/gohcl.DecodeBody/
.code recipy.go /type Action struct/,/"duration"/

Here: 
* **`duration`** will be loaded into the duration field because of the struct tag.
* **diags** — returned by almost all HCL calls — is a slice of diagnostics with
a context, they could be warnings or errors (ex: "file.go:L32 something is not
right")
* **`gohcl`** deduces HCL schemas using hcl tags.

## Okay, now we need a way to stack these ingredients

## Stacking stuff :

.code tartiflette.recipy.hcl /stack/,/onions/

## Stacking stuff :

.code tartiflette.recipy.hcl /stack/,/add/
.code recipy.go /var stack struct {/,/}/
.code recipy.go /gohcl.DecodeBody\(stackBody/

Here, we partially decode our stack block, and put everything unexpected in
stack.Rest.

## Defining a schema for 'add'

.code tartiflette.recipy.hcl /add/,/}/
.code recipy.go /case "add/,/}\n/

* Schemas allow to define the layout of an object more explicitly.
* These can be sent over the network.
* All of these hcldec types define the hcldec.Spec interface

## Now, we know:

* how to open an HCL file
* how to extract a block or a variable from a body

Now let's learn how to use variables and function.

## EvalContext allows to define variables and functions.

.code tartiflette.recipy.hcl /minutes/
.code recipy.go /var durationEvalCtx/,/}$/
.code recipy.go /durationEvalCtx,/

## gohcl from hcl/v2 seems to be the most imported

.image who_uses_what.png

`*` Nomad's old versions uses hcl v1

## Now, let's find variable references in my 'add' blocks


## Now, to list variable references in my 'add' block

## Pro tips

* It is better to decouple parsing or decoding from execution, just like in a
compiler.
* 